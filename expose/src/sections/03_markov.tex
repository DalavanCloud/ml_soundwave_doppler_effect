\section{\acl{HMM}}
\textit{Paul Pasler, Sebastian Rieder}

\acl{HMM} sind prädestiniert für diese Aufgabe \cite{mmmFink}, leider sind die APIS scheiße bzw wir zu blöd\ldots
\cite{rabiner}
Grundlage des \acl{HMM} waren die nach dem russischen Mathematiker Andrej Andrejewitsch Markov 
(1856 - 1922, siehe \cite{wiki:markov}) benannten Markov-Modelle. Zu Beginn des 20. Jahrhunderts 
beschäftigte er sich als erster mit einer statistischen Beschreibung von Zustands- und Symbolfolgen. 
Er führte eine statistische Analyse der Buchstabenfolge des Textes ``Eugen Onegin'' von Alexander 
Pushkin.

Der amerikanischen Mathematiker Leonard E. Baum (* 1931) und andere Autoren erweiterten dieses Konzept Ende der 
sechziger Jahre und nannten es \acl{HMM}. Erste \acl{HMM}-Applikationen wurden zur Spracherkennung und später auch in der Bioinformatik 
zur Analyse von Nukleotid- und Proteinsequenzen eingesetzt. 
 
\subsection{Markov-Ketten}
Markov-Ketten funktionieren so \ldots kling komisch, ist aber so


\subsection{\acl{HMM} und \acl{GMM}}
\acl{HMM} erweitern das Konzept der Markov-Ketten um eine zustandsspezifische Ausgabe und eine statistisch 
modellierte Zustandsfolge.

    dp = d.DataUtil()
    data= dp.loadRaw3dGesture(gesture)
    data = dp.reduceBins(data)
    data = dp.normalize(data)
    data = dp.normalizeBound(data)
    data = dp.cutRelevantAction(data)
    data = dp.round(data)
    data = dp.cutBad(data)
\subsection{Datenvorbereitung}
Ziel war es zuallererst die Datenmenge zu reduzieren, um das Trainingergebnis zu verbessern bzw. schneller zu machen.
\textbf{reduceBins} Da sich Änderungen durch eine Bewegung sehr Nahe am gesendeten Signal liegen, werden die Daten im 
Frequenzbereich von 18.000hz bis 19000hz betrachtet, die Daten vermindern sich von 64 auf 13 Werte. 
Dazu wird jede Geste auf einem Intervall von 0 bis 1 normalisiert (Geteilt durch den jeweiligen Maximalwert) und 
auf zwei Nachkommstellen gerundet. 
Alle Werte unterhalb eines Schwellwerts (0.1) werden zudem abgeschnitten, um niedrig amplitudiges Rauschen zu vermindern. 
So wird im Idealfall nur das gesendete Signal und Frequenzänderungen durch eine Geste dargestellt.

Wichtig ist nun den Beginn und das Ende einer Geste zu finden. Hierzu werden pro Frame alle Werte addiert 
und das Maximum als Mittelpunkt der Geste genutzt. Von diesem Gestenhöhepunkt werden jeweils 6 Frames davor und danach mitgenutzt.

So wird aus einem 32 x 64 Array pro Geste ein 13x13 Array.


\subsection{Implementierung}
Wir haben uns für die scipy HMM implementierung entschieden. 
Genutzt wird ein \acl{HMM} mit \acl{GMM} entschieden.


\subsection{Evaluation und Fazit}
